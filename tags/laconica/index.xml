<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Laconica on Blog | Federico Marani</title>
    <link>/tags/laconica/index.xml</link>
    <description>Recent content in Laconica on Blog | Federico Marani</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.</copyright>
    <atom:link href="/tags/laconica/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Tag-based routing in laconi.ca</title>
      <link>/blog/tag-based-routing-in-laconica/</link>
      <pubDate>Thu, 02 Apr 2009 23:15:09 +0000</pubDate>
      
      <guid>/blog/tag-based-routing-in-laconica/</guid>
      <description>

&lt;p&gt;Following the last article, i have been experimenting again on laconica and pubsub, this time on the idea of &amp;ldquo;&lt;a href=&#34;http://metajack.im/2009/01/22/filtering-the-real-time-web/&#34; target=&#34;_blank&#34;&gt;filtering the real time web&lt;/a&gt;&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Stomp and generally JMS messages offer the ability to specify headers and body of the message to transmit, in a way that resembles http requests.
In fact, Stomp protocol is really similar to Http protocol, at least in the general structure. The difference is that there are different methods instead of GET, POST, etc..
&lt;blockquote&gt;HTTP:
&lt;code&gt;
POST /item HTTP/1.0
Header: value&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;POSTBODY&lt;/blockquote&gt;
&lt;blockquote&gt;STOMP (after CONNECT command)
&lt;code&gt;
SEND
destination: /item&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;MESSAGE_BODY&lt;/blockquote&gt;
Very readable, like HTTP. However the main difference is that Stomp, like XMPP, is a stateful and bidirectional protocol.&lt;/p&gt;

&lt;p&gt;Like XMPP/pubsub, with STOMP and AMQP you can subscribe to a topic (a.k.a. pubsub node). However content-based routing is only done by STOMP and AMQP (in a way specified by the standard).
AMQP is still in its early days. STOMP is a ready-to-use protocol as many of its implementations.&lt;/p&gt;

&lt;p&gt;In the Stomp SUBSCRIBE operation it is possible to specify a JMS Selector. It&amp;rsquo;s a header passed when subscribing and it contains a SQL-92 Statement. SQL attributes to match the conditions against are the other headers.&lt;/p&gt;

&lt;h2 id=&#34;filtering-laconica-public-timeline-by-tags&#34;&gt;FILTERING LACONICA PUBLIC TIMELINE BY TAGS&lt;/h2&gt;

&lt;p&gt;Before filtering, the code of the previous post used to push notices needs to be enriched a bit. Particularly, tags present in the notices are now put in a separate header.
Doing this allows to be the target of a Selector.&lt;/p&gt;

&lt;p&gt;Push an additional header:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;//send tags as headers, so they can be used as JMS selectors
common_log(LOG_DEBUG, &#39;searching for tags &#39; . $notice-&amp;gt;id);
$tags = array();
$tag = new Notice_tag();
$tag-&amp;gt;notice_id = $notice-&amp;gt;id;
if ($tag-&amp;gt;find()) {
while ($tag-&amp;gt;fetch()) {
common_log(LOG_DEBUG, &#39;tag found = &#39; . $tag-&amp;gt;tag);
array_push($tags,$tag-&amp;gt;tag);
}
}
$tag-&amp;gt;free();

$con-&amp;gt;send(&#39;/topic/laconica.allusers&#39;,
$notice-&amp;gt;content,
array(
&#39;profile_id&#39; =&amp;gt; $notice-&amp;gt;profile_id,
&#39;tags&#39; =&amp;gt; implode($tags,&#39; &#39;)
)
);
common_log(LOG_DEBUG, &#39;sent to catch-all topic &#39; . $notice-&amp;gt;id);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Stomp client is really similar to the one of the previous post, but it specifies the additional header &amp;ldquo;selector&amp;rdquo; passed when subscribing.&lt;/p&gt;

&lt;p&gt;The selector here is &amp;ldquo;tags LIKE %dent%&amp;rdquo;. This matches all the posts that contains the tag #dent. Substitute it to match the tag you want&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
&amp;lt;?php

require_once &amp;quot;Stomp.php&amp;quot;;

$con = new Stomp(&#39;tcp://localhost:61613&#39;);
if (!$con-&amp;gt;connect())
    print &#39;conn failed&#39;;

$what = &#39;/topic/laconica.allusers&#39;;

$query = &#39;tags LIKE \&#39;%dent%\&#39;&#39;;

if (!$con-&amp;gt;subscribe($what,array(&amp;quot;selector&amp;quot; =&amp;gt; $query)))
    print &amp;quot;sub failed&amp;quot;;
else
    print &amp;quot;sub to &amp;quot;.$what.&amp;quot; successful\n&amp;quot;;

while (true) {
    $msg = $con-&amp;gt;readFrame();
    if ($msg) {
        print $msg-&amp;gt;headers[&#39;profile_id&#39;].&amp;quot;: &amp;quot;.$msg-&amp;gt;body. &amp;quot; -- &amp;quot;;
        print &amp;quot;msg_time:&amp;quot;.$msg-&amp;gt;headers[&#39;created&#39;].&amp;quot; &amp;quot;;
        print &amp;quot;tags: &amp;quot;.$msg-&amp;gt;headers[&#39;tags&#39;].&amp;quot;\n&amp;quot;;
        $con-&amp;gt;ack($msg);
    }
}

$con-&amp;gt;disconnect();
?

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>About the use of queues and pubsub in Laconi.ca</title>
      <link>/blog/about-the-use-of-queues-and-pubsub-in-laconica/</link>
      <pubDate>Sun, 15 Mar 2009 19:57:51 +0000</pubDate>
      
      <guid>/blog/about-the-use-of-queues-and-pubsub-in-laconica/</guid>
      <description>

&lt;p&gt;Lately i have been working on the idea of queues and pubsub mechanisms and how it is possible to integrate them in a microblogging service. I am fascinated by messaging protocols and event pushing!&lt;/p&gt;

&lt;p&gt;Let me say that XMPP is in my opinion the protocol of the future, however its pubsub implementation is quite complex if compared to what STOMP offers, and I didn&amp;rsquo;t find any mature PHP library.&lt;/p&gt;

&lt;p&gt;AQMP and STOMP are more suitable for internal processing, while XMPP is the perfect option for exposing data to the outside world and perhaps to connect desktop clients with microblogging services.&lt;/p&gt;

&lt;p&gt;Apart from my opinions, STOMP is a mature protocol with a PHP library that works pretty well and  Apache ActiveMQ, the message broker, offers access using several protocols.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;INTRODUCING A MESSAGE BROKER IN LACONI.CA&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;If queues are enabled in laconi.ca, it is possible to modify common_enqueue_notice() (called after the storage of the dent) in order to push the dent in the 4 queues that the software uses (OMB, jabber, sms, public), or simply push the dent in one and configure 3 mirror queues.&lt;/p&gt;

&lt;p&gt;In this way the internal queue system is not used. Queue_item::top() has potential race conditions and polls the db every 5 seconds. That means that if we&amp;rsquo;re lucky we get the message quickly, if unlucky in 5 seconds. Latency could even be something secondary, but the system now is pretty inefficient.&lt;/p&gt;

&lt;p&gt;If laconi.ca passes the message to an external broker, delivery would be more efficient and it is a piece of code that the community wouldn&amp;rsquo;t have to maintain.&lt;/p&gt;

&lt;p&gt;The downside of this is that another software is on the list of requirements. However, if you have the possibility to run queuehandlers in background, it probably means you own the server and you can afford to install a message broker. Queues can still be disabled and the system still works without queues and message brokers, the only difference is that everything is done synchronously.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;WITH A MESSAGE BROKER, PUBSUB COMES FOR FREE&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Another feature of ActiveMQ is the use of &amp;ldquo;topics&amp;rdquo;. The main differences between queues and topics are that in the queues messages are sent to only one consumer (precisely, round-robin among consumers) and messages are persistent (stored internally while waiting consumers to connect). Topics are the opposite, the same message is sent to all its consumers that are currently connected to the broker.&lt;/p&gt;

&lt;p&gt;Topics could be used for introducing a publish-subscribe system in Laconi.ca. In common_enqueue_notice() with only some lines of code it is possible to push each dent to topics such as &amp;ldquo;/topic/laconica.user.IDUSER&amp;rdquo;, &amp;ldquo;/topic/laconica.allusers&amp;rdquo; or do more complex association like &amp;ldquo;/topic/laconica.group.IDGROUP&amp;rdquo; and &amp;ldquo;/topic/laconica.tag.TAGNAME&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;With a topic dedicated to a group and using the XMPP endpoint of ActiveMQ, you can also gain MUC support in Laconi.ca (only read-only if there isn&amp;rsquo;t an handler)&lt;/p&gt;

&lt;p&gt;Offering pubsub using ActiveMQ and STOMP calls is very easy, however i am not sure how interoperable this solution could be. I did not find any XMPP/Pubsub interface for ActiveMQ, although topics could be easily mapped to XMPP/Pubsub nodes.&lt;/p&gt;

&lt;p&gt;If the pubsub notifications have to be XMPP based, i see two solutions: write a wrapper that gets all the messages via an ActiveMQ queue and speaks XMPP with ejabberd, or forget about ActiveMQ and use XMPP requests directly, perhaps using an AtomPub interface.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;POSSIBLE FUTURE DIRECTIONS&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Integrating queues at the end of the stack is not going to help much in terms of performance or flexibility of the whole system, but it&amp;rsquo;s a first step and, as they&amp;rsquo;re used marginally, they&amp;rsquo;re still an optional requirement.&lt;/p&gt;

&lt;p&gt;With all these ideas around, like offering XMPP MUC support, AtomPub interfaces, XMPP/Pubsub output, etc.. in the future the system would have to be &amp;ldquo;decoupled&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;An input system that pushes dents in a queue as quickly as possible. The main Laconi.ca logic that works in the background and asynchronously. The internal logic will then push the info to queue handlers for real-time delivery AND store the dents in the DB. The main website will still poll data from the DB, with all the necessary caching layers, OR/AND poll directly the message broker for the required type of dent (see the list of topics mentioned before) via AJAX calls (ActiveMQ has support for that).&lt;/p&gt;

&lt;p&gt;Any feedback is appreciated, or suggestions on things i might have overlooked! I am not an expert of message queue system so many of the things i have said may seem obvious, but not to someone who has a background of normal website and MVC development so i clearly stated all the steps&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;WHAT I DID&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
function common_enqueue_notice($notice)
{
if (common_config(&amp;lsquo;queue&amp;rsquo;,&amp;lsquo;subsystem&amp;rsquo;) == &amp;lsquo;stomp&amp;rsquo;) {
// use an external message queue system via STOMP
require_once(&amp;ldquo;Stomp.php&amp;rdquo;);
$con = new Stomp(common_config(&amp;lsquo;queue&amp;rsquo;,&amp;lsquo;stomp_server&amp;rsquo;));
if (!$con-&amp;gt;connect()) {
common_log(LOG_ERR, &amp;lsquo;Failed to connect to queue server&amp;rsquo;);
return false;
}
$queue_basename = common_config(&amp;lsquo;queue&amp;rsquo;,&amp;lsquo;queue_basename&amp;rsquo;);
foreach (array(&amp;lsquo;jabber&amp;rsquo;, &amp;lsquo;omb&amp;rsquo;, &amp;lsquo;sms&amp;rsquo;, &amp;lsquo;public&amp;rsquo;) as $transport) {
if (!$con-&amp;gt;send(
&amp;lsquo;/queue/&amp;rsquo;.$queue_basename.&amp;lsquo;-&amp;rsquo;.$transport, // QUEUE
$notice-&amp;gt;id,            // BODY of the message
array (                 // HEADERS of the msg
&amp;lsquo;created&amp;rsquo; =&amp;gt; $notice-&amp;gt;created
))) {
common_log(LOG_ERR, &amp;lsquo;Error sending to &amp;lsquo;.$transport.&amp;rsquo; queue&amp;rsquo;);
return false;
}
common_log(LOG_DEBUG, &amp;lsquo;complete remote queueing notice ID = &amp;rsquo; . $notice-&amp;gt;id . &amp;lsquo; for &amp;rsquo; . $transport);
}
$con-&amp;gt;send(&amp;lsquo;/topic/laconica.&amp;rsquo;.$notice-&amp;gt;profile_id,
$notice-&amp;gt;content,
array(
&amp;lsquo;profile_id&amp;rsquo; =&amp;gt; $notice-&amp;gt;profile_id,
&amp;lsquo;created&amp;rsquo; =&amp;gt; $notice-&amp;gt;created
)
);
$con-&amp;gt;send(&amp;lsquo;/topic/laconica.allusers&amp;rsquo;,
$notice-&amp;gt;content,
array(
&amp;lsquo;profile_id&amp;rsquo; =&amp;gt; $notice-&amp;gt;profile_id,
&amp;lsquo;created&amp;rsquo; =&amp;gt; $notice-&amp;gt;created
)
);
$result = true;
}
else {
// in any other case, &amp;lsquo;internal&amp;rsquo;
foreach (array(&amp;lsquo;jabber&amp;rsquo;, &amp;lsquo;omb&amp;rsquo;, &amp;lsquo;sms&amp;rsquo;, &amp;lsquo;public&amp;rsquo;) as $transport) {
$qi = new Queue_item();
#OTHER OLD CODE&amp;hellip;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This code sends the dent to 4 queues and 2 topics. Queues are used by the 4 background queuehandlers while 2 topics offer a simple pubsub service to either a single userid or to all of them (public timeline).&lt;/p&gt;

&lt;p&gt;As regards queues, queuehandler.php has to be modified:
&lt;code&gt;&lt;/p&gt;

&lt;h1 id=&#34;called-by-run&#34;&gt;called by run()&lt;/h1&gt;

&lt;p&gt;function stomp_dispatch() {
require(&amp;ldquo;Stomp.php&amp;rdquo;);
$con = new Stomp(common_config(&amp;lsquo;queue&amp;rsquo;,&amp;lsquo;stomp_server&amp;rsquo;));
if (!$con-&amp;gt;connect()) {
$this-&amp;gt;log(LOG_ERR, &amp;lsquo;Failed to connect to queue server&amp;rsquo;);
return false;
}
$queue_basename = common_config(&amp;lsquo;queue&amp;rsquo;,&amp;lsquo;queue_basename&amp;rsquo;);
// subscribe to the relevant queue (format: basename-transport)
$con-&amp;gt;subscribe(&amp;lsquo;/queue/&amp;rsquo;.$queue_basename.&amp;lsquo;-&amp;rsquo;.$this-&amp;gt;transport());
do {
$frame = $con-&amp;gt;readFrame();
if ($frame) {
$this-&amp;gt;log(LOG_INFO, &amp;lsquo;Got item enqueued &amp;lsquo;.common_exact_date($frame-&amp;gt;headers[&amp;lsquo;created&amp;rsquo;]));
// XXX: Now the queue handler receives only the ID of the
// notice, and it has to get it from the DB
// A massive improvement would be avoid DB query by transmitting
// all the notice details via queue server&amp;hellip;
$notice = Notice::staticGet($frame-&amp;gt;body);
if ($notice) {
$this-&amp;gt;log(LOG_INFO, &amp;lsquo;broadcasting notice ID = &amp;rsquo; . $notice-&amp;gt;id);
$result = $this-&amp;gt;handle_notice($notice);
if ($result) {
// if the msg has been handled positively, ack it
// and the queue server will remove it from the queue
$con-&amp;gt;ack($frame);
$this-&amp;gt;log(LOG_INFO, &amp;lsquo;finished broadcasting notice ID = &amp;rsquo; . $notice-&amp;gt;id);
}
else {
// no ack
$this-&amp;gt;log(LOG_WARNING, &amp;lsquo;Failed broadcast for notice ID = &amp;rsquo; . $notice-&amp;gt;id);
}
$notice-&amp;gt;free();
unset($notice);
$notice = null;
} else {
$this-&amp;gt;log(LOG_WARNING, &amp;lsquo;queue item for notice that does not exist&amp;rsquo;);
}
}
} while (true);
$con-&amp;gt;disconnect();
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Here there&amp;rsquo;s the code for a simple pubsub consumer
&lt;code&gt;
require_once &amp;ldquo;Stomp.php&amp;rdquo;;
$con = new Stomp(&amp;lsquo;tcp://localhost:61613&amp;rsquo;);
if (!$con-&amp;gt;connect())
print &amp;lsquo;conn failed&amp;rsquo;;
$what = &amp;lsquo;/topic/laconica.2&amp;rsquo;;
if (!$con-&amp;gt;subscribe($what))
print &amp;ldquo;sub failed&amp;rdquo;;
else
print &amp;ldquo;sub to &amp;ldquo;.$what.&amp;rdquo; successful\n&amp;rdquo;;
while (true) {
$msg = $con-&amp;gt;readFrame();
if ($msg) {
print $msg-&amp;gt;headers[&amp;lsquo;profile_id&amp;rsquo;].&amp;rdquo;: &amp;ldquo;.$msg-&amp;gt;body. &amp;rdquo; &amp;ndash; &amp;ldquo;;
print &amp;ldquo;msg_time:&amp;ldquo;.$msg-&amp;gt;headers[&amp;lsquo;created&amp;rsquo;].&amp;rdquo; &amp;ldquo;;
print &amp;ldquo;received:&amp;ldquo;.date(&amp;ldquo;Y-m-d H:i:s&amp;rdquo;).&amp;rdquo;\n&amp;rdquo;;
$con-&amp;gt;ack($msg);
}
}
$con-&amp;gt;disconnect();
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Except the last bit, all this code is on the fmarani-clone of the dev repo on gitorious, branch 0.8.x&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>