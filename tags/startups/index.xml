<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Startups on Blog | Federico Marani</title>
    <link>/tags/startups/index.xml</link>
    <description>Recent content in Startups on Blog | Federico Marani</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.</copyright>
    <atom:link href="/tags/startups/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Minimalism is how startups keep the focus</title>
      <link>/blog/minimalism-is-how-startups-keep-focus/</link>
      <pubDate>Sat, 18 Mar 2017 16:30:28 +0000</pubDate>
      
      <guid>/blog/minimalism-is-how-startups-keep-focus/</guid>
      <description>

&lt;p&gt;I want to blog about this topic because minimalism, meant as the art of doing only the essential, is a very hard thing to do. Writing about things helps me with having a clear mind. I will therefore try to write about it, and rewrite about it in the future as many times as my thinking clears up.&lt;/p&gt;

&lt;p&gt;I realize this article will leave you with a ton of space for interpretation. You may have more questions after reading this than answers. This is the goal of this article.&lt;/p&gt;

&lt;p&gt;I had the chance to work on some big projects last year, and this year slightly smaller projects, where my job was sitting somewhere between coding and delivery. This was a personal choice. In this space, if there is a &amp;ldquo;bug&amp;rdquo;, its cost is usually tenfold, because it has a cascading effect. Sometimes it could be the kind of bug that you cannot fix later.&lt;/p&gt;

&lt;p&gt;Industry got smarter on this, with safety nets to catch bad practices, but I struggle to support this one-size-fits-all approach that seems to permeate the software industry. Approaches like Best Practices, SCRUM, 3-layer architecture, DRY, JIRA, NoSQL, REST, modularity, reusability, unit-testing, microservices. There are pros and cons for each one of these, and blogged at length by the engineering community. I acknowledge that each one of these acronyms provide common ground for processes and discussions, but why do we have to use them if in our context they do more harm than good?&lt;/p&gt;

&lt;p&gt;How do we communicate we want to do something different, because the current industry standard has arguably some problems?&lt;/p&gt;

&lt;p&gt;Can we advocate for DRY when we have never seen 5-6 codebases tumbling down the copy-paste route? Can we advocate for unit-tests when every new feature is 90% a rewrite of the old one? Is NoSQL better because it is newer than SQL? Why REST when there is no clear resource to act on? Unfortunately, there is no silver bullet, but we still communicate ground rules by picking an existing approach rather than coming up with one.&lt;/p&gt;

&lt;p&gt;I think the only universal solution here is to only do what is needed, but there are no guidelines that help you choose to not do something. Let&amp;rsquo;s try to have a framework to take minimalistic decisions. I can count 5 levels in which minimalism can be applied.&lt;/p&gt;

&lt;h2 id=&#34;product-minimalism&#34;&gt;Product minimalism&lt;/h2&gt;

&lt;p&gt;Every feature needs to be mantained. When tackling a roadmap, usually features are added and products created, but this is hardly sustainable in the long term. If you compare building software to building houses, you will understand that you cannot always add rooms without rethinking the house plan.&lt;/p&gt;

&lt;p&gt;Product is the medium for business to take place. It needs to be clean and clear. I think the product needs to be minimized so it is very clear what it is. Every time we add something that is not connected with the primary goal of the business, we accumulate product debt. Debt that need to be repaid by either forming a business structure around it, or by removing it from the codebase.&lt;/p&gt;

&lt;p&gt;I have been thinking about negative roadmaps lately, which is a list of things you decided not to have anymore, or split out in its separate product with a separate support. I think if everything is measured in usage numbers, it should be pretty clear what is valuable and what is not.&lt;/p&gt;

&lt;h2 id=&#34;architecture-minimalism&#34;&gt;Architecture minimalism&lt;/h2&gt;

&lt;p&gt;How many databases, how many frameworks, languages and libraries do you need to build your product? Does each one of these choices justify the time invested in learning and maintaining it? Do they enable you to do something that you would not be able to do otherwise?&lt;/p&gt;

&lt;p&gt;I am not against using the right tool for the job. I think sometimes it is better to have a flexible tool for the job instead of many right tools. This type of choice buys you options and gives you only one thing to care about.&lt;/p&gt;

&lt;p&gt;How about a tool that fits you 90%? Does another tool that covers the remaining 10% justifies the added business value?&lt;/p&gt;

&lt;p&gt;As a last thing, this is connected to product minimalism. Any product reduction or modification should reflect on here. If a product feature is removed, but you still keep the underlying software architecture for it, you have architecture debt.&lt;/p&gt;

&lt;p&gt;I do not think architecture design by committee works, ever, especially in startups. At the same time, one person designing this and telling the team the outcome does not work either.&lt;/p&gt;

&lt;p&gt;Please value your team opinions, but ultimately good points need to be discerned from bad ones, and the last ones discarded. Listening does not mean doing everything everybody wants.&lt;/p&gt;

&lt;h2 id=&#34;infrastructure-minimalism&#34;&gt;Infrastructure minimalism&lt;/h2&gt;

&lt;p&gt;The amount of effort you need to put in managing a network of servers is often undervalued. DevOps can drain a lot of your time if you are not careful.&lt;/p&gt;

&lt;p&gt;I found that the average developer is quite bad at infrastructure, perhaps because they are different disciplines. This could be part of the reason why microservices are becoming such a buzzword nowadays.&lt;/p&gt;

&lt;p&gt;Plenty has been written about microservices and how you should practice a monolith first approach when the business is young and the product is still in its definition phase. I agree with the general idea.&lt;/p&gt;

&lt;p&gt;From a infrastructure management perspective, microservices is the worst option: you have to manage a distributed system with multiple points of failure which needs careful coordination when releasing, especially paying attention to forward and backward compatibility of their REST interfaces (or any other i/o format). Essentially a full-time job.&lt;/p&gt;

&lt;p&gt;A much better use of your time is to lay down the infrastructure in a way that is easy to automate. You should aim to have a script for everything. Creating servers, installing databases, deploy and releasing code, etc. If you know you may have to do what you did a second time, automate it. If you are not sure, at least document it.&lt;/p&gt;

&lt;h2 id=&#34;code-minimalism&#34;&gt;Code minimalism&lt;/h2&gt;

&lt;p&gt;I feel like here there is potentially the biggest impact for this. Only create software layers and apply clever design patterns if they provide better common groud for the team, which can then use those to apply higher level thinking. In the other words, the abstraction needs to be good and solid. If an abstraction leaks, it is time to remove it, for the same reason you would remove a leaky pipe from your kitchen.&lt;/p&gt;

&lt;p&gt;Recently I read some advice that was saying that you should write code in a way that is easy to remove. I think it is a good starting point to think about this.&lt;/p&gt;

&lt;p&gt;I think in the engineering profession there is a lot of intellectual pride in being picked to build the backbone of a new codebase, but sometimes comes with intellectual arrogance attached. Building software is expected to be a very fluid process, and it can probably be that way if we try to limit the number of hard choices we feel the urge to make.&lt;/p&gt;

&lt;h2 id=&#34;process-minimalism&#34;&gt;Process minimalism&lt;/h2&gt;

&lt;p&gt;For me, there is nothing worse than having too many processes, but I also understand that for some type of people having a process for communicating gives you more comfort.&lt;/p&gt;

&lt;p&gt;First off, processes are about communication, therefore they can be of two kinds: asynchronous and synchronous. Synchronous comunications are more costly in terms of stress and interruption of flow, but sometimes lead to solutions more quickly.&lt;/p&gt;

&lt;p&gt;If your focus is progressing with work, the worst option is having a synchonous communication session that does not lead to any helpful outcome to anyone. If your focus is having fun, take 2 hours off at the end of the day and go to the pub. Nobody can claim to do constant progress 8 hours a day.&lt;/p&gt;

&lt;p&gt;To me, the minimum set of meetings an engineering team should have are the ones, with explicit no blame policy, that are dedicated to voicing concerns (or support) towards specific team processes, architecture, infrastructure or code. Better if these areas are taken one at a time. What in SCRUM terms is called retrospective is one of these.&lt;/p&gt;

&lt;h2 id=&#34;conclusions&#34;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;If our goal is to do the things that work and do not do the things that do not work, we have to be open minded and question everything.&lt;/p&gt;

&lt;p&gt;The product you do not put together will not confuse your user, the architecture you do not insert in your repository will not give any more headaches to engineers, the infrastructure you do not provision on your servers will not break, the process you do not have in place will avoid people telling you they have too many meetings. The code you do not write never crashes.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s agree that sometimes not doing, or undoing, something is a better course of action.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>YCombinator interview</title>
      <link>/blog/yc-interview/</link>
      <pubDate>Sun, 01 May 2016 20:43:48 +0000</pubDate>
      
      <guid>/blog/yc-interview/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;../../attachments/ycombinator.png&#34; alt=&#34;YC&#34; /&gt;&lt;/p&gt;

&lt;p&gt;A month ago me and my co-founder did an application for YC, and last week we were lucky enough to be selected for an interview, along with other startups. We got called all the way to California with not even a week of notice, everything paid&amp;hellip; definitely a bit more serious than a phone call.&lt;/p&gt;

&lt;p&gt;We prepared a lot during the last few days, reading what people say online, meeting previous YC companies, doing mock interviews with YC alumni. Some of that was YC specific, as we knew they are very product-focused. Little aside here: I am an engineer and I really dislike sales talk, because most sales words are so vague that are worthless at describing specifics. It was very refreshing to see that YC thought it the same way I did.&lt;/p&gt;

&lt;p&gt;The interview only lasted 10 minutes, although we got a second interview with other partners, so they had listened to our story twice. There were 3-4 groups of 3 partners doing interviews for max 10 min throughout the day, for 2 weeks, so you can imagine there were a lot of companies there, all with their online application accepted. I have spoken with a few of them, all clearly smart, although at that stage you practiced your pitch so many times that you do not want to hear yourself having to say it again :-)&lt;/p&gt;

&lt;p&gt;If there is one take-away for me is: explain the product, as opposed to sell the product. Explain it in a way that someone technical might be able to rebuild it. Describe it well in a way that sales processes, addressable markets, customer acquisition strategies and costs, LTV, who buys and who uses it, all these should all come naturally from the product description. You should have a good answer for all these, even if not perfect yet.&lt;/p&gt;

&lt;p&gt;In the same evening we received a negative answer, along with some good feedback. When things do not go as you would, it is easy to be dismissive, but really, there is a lot that could be learnt if you were in. I would definitely go back if we had the chance.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Another failure, another lesson - comprotempo.it</title>
      <link>/blog/comprotempo/</link>
      <pubDate>Wed, 11 Mar 2015 12:00:00 +0000</pubDate>
      
      <guid>/blog/comprotempo/</guid>
      <description>&lt;p&gt;When it came out, I was fashinated by TaskRabbit. I thought that a generic marketplace for handymen was the perfect tool for this decade. We have lots of young unemployment in Italy and there were also middle-class people willing to pay for someone doing chores for them. The idea was simple: putting both sides in touch by agreeing location, type of task and price. The advantages for handymen were money for work, the advantages for the committant is to &amp;ldquo;buy&amp;rdquo; someone else&amp;rsquo;s time (hence the &amp;ldquo;comprotempo&amp;rdquo; name)&lt;/p&gt;

&lt;p&gt;In 2012, I set out to replicate the idea and find a good team of people to work with. I am an engineer, it is easy for us to &amp;ldquo;over-build&amp;rdquo; the product, or &amp;ldquo;over-engineer&amp;rdquo; a product feature, so I only built what I thought was the minimum product. Everybody is biased in some ways, working in a team is the only way to keep these biases in check. Once I built it, 2-3 months later, it was about spreading the word: Facebook page, Twitter account, PPC on various channels, writing content, reaching out to people, etc&amp;hellip;&lt;/p&gt;

&lt;p&gt;Turns out building a Marketplace is very hard. You have now to convince two types of customers which may have a completely different set of concerns and motivations. The money incentive is always very strong, in fact we had a lot of users registered as handymen for a very broad set of tasks. On the other hand, feeding the system with tasks has proven to be very challenging.&lt;/p&gt;

&lt;p&gt;Because we started with handling a broad set of tasks, we had a problem with audience addressability: people likely to buy services on our site were not very addressable, distinguishable from the crowd. For instance, how do you target people willing to pay for lawn mowing, and willing to trust an online service for it? Not easy. We had to do that for every type of service the site was offering, so it was hardly marketing scalable. Some of these services were by nature recurrent, most of them were not though.&lt;/p&gt;

&lt;p&gt;We were also doing a bad job at keeping people&amp;rsquo;s attention on the site. The homepage was generic on purpose, and I don&amp;rsquo;t think people were understanding the relevance to their problem. Also they were very likely to be busy people, I think we were wasting their attention timespan. Posting an ad for a task also required filling a lot of information about the task before-hand, in order to receive good money quotes for it. People don&amp;rsquo;t like long forms.&lt;/p&gt;

&lt;p&gt;Most of all, I think we had done a very bad job at building trust as a community. We had a rating system for handymen, but with no user-generated ratings it was not helpful. It is a bit of a chicken-and-egg problem sometimes, communities are not self-sustaining from the start. Building brand reputation is just really long and hard.&lt;/p&gt;

&lt;p&gt;At the end, we also had problems with the team. With internal divisions, you just cannot focus your energies anymore. I can&amp;rsquo;t stress this enough, problems with founding team are just incredibly hard to deal with. They ripple out into everything else. That was the end for us.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>