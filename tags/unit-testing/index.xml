<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Unit Testing on Blog | Federico Marani</title>
    <link>/tags/unit-testing/index.xml</link>
    <description>Recent content in Unit Testing on Blog | Federico Marani</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.</copyright>
    <atom:link href="/tags/unit-testing/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Dbunit testing</title>
      <link>/blog/dbunit-testing/</link>
      <pubDate>Sun, 17 Oct 2010 13:09:26 +0000</pubDate>
      
      <guid>/blog/dbunit-testing/</guid>
      <description>&lt;p&gt;This article is about PHPUnit used in conjunction with DBUnit to test PHP code that interacts with a database server.&lt;/p&gt;

&lt;p&gt;Please note that DBUnit is able to load and unload sets of data to the db but does not handle table creation and queries that alter structures. This is responsibility of an ORM or an initial sql script that creates/rebases the initial environment.&lt;/p&gt;

&lt;p&gt;Code i wrote is run against a very simple ORM implementation we currently use in my workplace. Code should be simple enough to follow.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DB Unit test&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A dbunit test is basically a unit-test which inherits from PHPUnit_Extensions_Database_TestCase and declares two more methods: getConnection() and getDataSet(). The first one must return the dbunit wrapper of PDO and the second a dataset representation created with create*Dataset() functions.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class TestAddress extends PHPUnit_Extensions_Database_TestCase
{
    private $fixture_addressId;
    private $fixture_location;

    public function setUp()
    {
        parent::setUp();
        $this-&amp;gt;fixture_addressId = &amp;quot;5&amp;quot;;
        $this-&amp;gt;fixture_location = &amp;quot;Melbourne&amp;quot;;
    }

    protected function getConnection()
	{
		$pdo = getPdo(); // replace this code
		return $this-&amp;gt;createDefaultDBConnection($pdo, &#39;testdb&#39;);
	}

    protected function getDataSet()
    {
        return $this-&amp;gt;createFlatXMLDataSet(dirname(__FILE__).&#39;/../fixtures/db-addresses.xml&#39;);
    }

    public function testBasicFixtureLoading()
    {
        $mapper = new address_Mapper();
        $address = $mapper-&amp;gt;findById($this-&amp;gt;fixture_addressId);
        
        $this-&amp;gt;assertEquals($address-&amp;gt;addressLine3, $this-&amp;gt;fixture_location);
    }

    public function testSave()
    {
        $mapper = new address_Mapper();
        $address = $mapper-&amp;gt;findById($this-&amp;gt;fixture_addressId);
        $address-&amp;gt;addressLine3 = &amp;quot;London&amp;quot;;
    	$mapper-&amp;gt;save($address);
    	unset($address);
        $address = $mapper-&amp;gt;findById($this-&amp;gt;fixture_addressId);
    	$this-&amp;gt;assertEquals(&amp;quot;London&amp;quot;, $address-&amp;gt;addressLine3);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;model object&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Model objects are a representation of data. They are basically a data container. They must not contain any integration logic (ex. database queries), that is responsibility of mapper objects.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class Address extends Model
{
	public function __construct()
	{
		parent::__construct(&#39;addressId&#39;);
		$this-&amp;gt;setFieldNames(array(
			&#39;addressId&#39;,
			&#39;firstName&#39;,
			&#39;lastName&#39;,
			&#39;addressLine1&#39;,
			&#39;addressLine2&#39;,
			&#39;addressLine3&#39;,
			&#39;addressLine4&#39;,
			&#39;state&#39;,
			&#39;postCode&#39;,
			&#39;country&#39;,
			&#39;createdDate&#39;
			));
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;mapper object&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Responsibility of mapper object is to populate and return correspondent models of data. In this case it returns address models. Our mapper class already offers generic find()/insert()/update()/delete() operation but you may want to extend it to use different find methods.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class address_Mapper extends Mapper
{
	const STORAGE_NAME = &#39;Addresses&#39;; // table name

	public function __construct()
	{
		parent::__construct(getPdo(), self::STORAGE_NAME, &#39;addressId&#39;);
	}

    public function findById($addressId)
    {
        $identity = array(&#39;addressId&#39; =&amp;gt; $addressId);
        $model = new Address;
        parent::find($identity, $model);
        return $model;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Fixture datasets&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;These are our test data. Each dbunit test has his own dataset. There are many formats available for PHPUnit, the one here is called FlatXMLDataset, which is really simple.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;dataset&amp;gt;
 &amp;lt;Addresses
   addressId=&amp;quot;5&amp;quot;
   firstName=&amp;quot;myName&amp;quot;
   lastName=&amp;quot;mySurname&amp;quot;
   addressLine1=&amp;quot;myAddr1&amp;quot;
   addressLine2=&amp;quot;myAddr2&amp;quot;
   addressLine3=&amp;quot;myAddr3&amp;quot;
   addressLine4=&amp;quot;Melbourne&amp;quot;
   state=&amp;quot;&amp;quot;
   country=&amp;quot;AU&amp;quot;
   postCode=&amp;quot;3400&amp;quot;
   createdDate=&amp;quot;18:16:19 2009-10-18&amp;quot;
  /&amp;gt;

 &amp;lt;Addresses
   addressId=&amp;quot;6&amp;quot;
   firstName=&amp;quot;Another&amp;quot;
   lastName=&amp;quot;Person&amp;quot;
   addressLine1=&amp;quot;Somewhere&amp;quot;
   addressLine2=&amp;quot;&amp;quot;
   addressLine3=&amp;quot;London&amp;quot;
   addressLine4=&amp;quot;&amp;quot;
   state=&amp;quot;&amp;quot;
   country=&amp;quot;UK&amp;quot;
   postCode=&amp;quot;XXX111&amp;quot;
   createdDate=&amp;quot;18:00:19 2009-10-18&amp;quot;
  /&amp;gt;
&amp;lt;/dataset&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each child tag of &lt;dataset&gt; is &lt;TABLE_NAME column1=&#34;value&#34;&gt; kind of syntax. Nothing more than that, no structure only data.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bootstrapping&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;As we said there is no table definition loading by default in DBunit. Initial environment must be setup before the dbunit test runs and this can be done using PHPUnit bootstrap files (see &amp;ndash;bootstrap option).&lt;/p&gt;

&lt;p&gt;It is not necessary to drop and recreate tables everytime but highly advisable, there could be cases in which the test is supposed to fail but it does not because it reads data that should not be in the database. That is why we need to control execution environment as much as possible.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;define(&amp;quot;FIXTURE_DB_REBASE&amp;quot;, dirname(__FILE__).&amp;quot;/fixtures/db-rebase.sql&amp;quot;);

// To test database-dependent classes you need a local database with the following settings
$host = &#39;localhost&#39;;
$user = &#39;unittests&#39;;
$password = &#39;myPassword&#39;;
$dbName = &#39;app_UnitTests&#39;;

// Create a database adapter
try {
    $dbh = new PDO(&amp;quot;mysql://&amp;quot;.$host.&amp;quot;/&amp;quot;.$dbName, $user, $password);
} catch (PDOException $e) {
    echo &#39;Connection failed: &#39; . $e-&amp;gt;getMessage();
}

// Ensure database credentials work
try {
    $results = $dbh-&amp;gt;query(&amp;quot;SHOW TABLES&amp;quot;)-&amp;gt;fetchAll();
} catch (PDOException $e) {
    echo &amp;quot;You need to create a local test database - see bootstrap.php for more details\n&amp;quot;;
    echo &amp;quot;Connection error: &amp;quot;.$e-&amp;gt;getMessage().&amp;quot;\n&amp;quot;;
    exit;
}

// rebase the database
$dbh-&amp;gt;query(file_get_contents(FIXTURE_DB_REBASE))-&amp;gt;closeCursor();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;DB rebase SQL fixture&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;--
-- Table structure for table &#39;Addresses&#39;
--

DROP TABLE IF EXISTS Addresses;
CREATE TABLE Addresses (
  addressId int(10) unsigned NOT NULL auto_increment,
  firstName varchar(128) NOT NULL,
  lastName varchar(128) NOT NULL,
  addressLine1 varchar(256) NOT NULL,
  addressLine2 varchar(256) NOT NULL,
  addressLine3 varchar(256) NOT NULL,
  addressLine4 varchar(256) NOT NULL,
  state varchar(128) NOT NULL,
  country varchar(128) NOT NULL,
  postCode varchar(32) NOT NULL,
  createdDate datetime NOT NULL,
  PRIMARY KEY  (addressId)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Making complex software not complicated</title>
      <link>/blog/making-complex-software-not-complicated/</link>
      <pubDate>Tue, 05 Oct 2010 20:32:05 +0000</pubDate>
      
      <guid>/blog/making-complex-software-not-complicated/</guid>
      <description>&lt;p&gt;I&amp;rsquo;d like to share my thoughts with you about approaching difficult problems in software development. This is pretty much what i came to realize after many years of development.&lt;/p&gt;

&lt;p&gt;A difficult problem is usually divisible in several simple problems, but when developing software you stack up problems and every problem relies on the solution of the sub-problem.&lt;/p&gt;

&lt;p&gt;Example (a common order visualizer)&lt;/p&gt;

&lt;pre&gt;
1st level of the stack:
1) display_order_in_xml() (relies on read_order())
1) display_order_in_json() (relies on read_order())
2nd:
2) read_order() (relies on read_orderitems() and an internal calculate_delivery())
3rd:
3) read_orderitems() (relies on items_mapper::find() OR read_items_from_external_shop())
4th - case 1 - items_mapper
4) items_mapper::find() (relies on a db_Adapter)
5) db_Adapter (no dependencies)
4th - case 2 - read_items_from_external_shop()
4) read_items_from_external_shop() (relies on json_call())
5) json_call() (depends on http class for sending requests)
6) http class (no dependencies)
&lt;/pre&gt;

&lt;p&gt;Solution here is to isolate each bit, and being able to feed a fixed solution of the sub-problem to the current problem. Isolating each bit allows us to solve one problem at a time, being able to pass dependencies to the constructor gives us the possibility to pass already computed solutions of the sub-problems.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class OrderDisplayer {
 public function __construct($orderReader) {
  $this-&amp;gt;orderReader = $orderReader; // without orderReader, this class has no reason to exist
 }
 public function toXml($orderNumber) {
  return $this-&amp;gt;doMagic($this-&amp;gt;orderReader-&amp;gt;read_order($orderNumber));
 }
}

class OrderReader {
 public function __construct($itemsReader, $calculator) {
  $this-&amp;gt;itemsReader = $itemsReader; // same here, without these 2 objects this class has no reason to exist
 }
 public function read($orderNumber) {
  $items = $this-&amp;gt;itemsReader-&amp;gt;read_orderitems($orderNumber));
  $delivery = $this-&amp;gt;calculator-&amp;gt;applyCrazyDeliveryCosts($items); // this will depend on a currency converter, which depends on a httpclient which connects to a webservice :)
 }
}

class ItemsReader {
 public function __construct($itemsMapper, $remoteItemsReader) {
  $this-&amp;gt;itemsMapper = $itemsMapper; // same story
  $this-&amp;gt;remoteItemsReader = $remoteItemsReader;
 }
 public function read($orderNumber) {
    $conditions = array(orderNumber == $orderNumber, itemCost &amp;gt; 0, day == today);
    $items = $this-&amp;gt;itemsMapper-&amp;gt;find($conditions);
    if (!$items) {
      $items = $this-&amp;gt;remoteItemsReader-&amp;gt;find($conditions);
    }
    return $items;
 }
}


class ItemsMapper {
 public function __construct($dbAdapter) {
  $this-&amp;gt;dbAdapter = $dbAdapter; // same story
 }
 public function find($conditions) {
    return $this-&amp;gt;dbAdapter-&amp;gt;query(&amp;quot;SELECT FROM Items WHERE &amp;quot;.$this-&amp;gt;getWhere($conditions));
 }
}


class remoteItemsReader {
 public function __construct($jsonRpcService) {
  $this-&amp;gt;jsonRpcService = $jsonRpcService; // same story
 }
 public function  read_items_from_external_shop($conditions) {
    $this-&amp;gt;serverList = array(&amp;quot;ecommerce.johnsmith.co.uk&amp;quot;, &amp;quot;www.bestshopever.com.au&amp;quot;);
    foreach ($this-&amp;gt;serverList as $server) {
     $items = $this-&amp;gt;jsonRpcService-&amp;gt;json_call($server, $this-&amp;gt;getJsonBody($conditions));
     if (count($items) &amp;gt; 0)
       return $items;
    }
 }
}


class JsonRpcService {
 public function __construct($httpService) {
  $this-&amp;gt;httpService = $httpService; // same story
 }
 public function json_call($server, $jsonCall) {
   $this-&amp;gt;httpService-&amp;gt;connect($server);
    return $this-&amp;gt;httpService-&amp;gt;postAndReadAnswer(&amp;quot;/jsonrpc.php&amp;quot;, $jsonCall);
 }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each of these classes are unit-testable, which represents the software unit of measurement of isolation. Ability to feed intermediate solutions to the dependent problems comes from mocked objects:&lt;/p&gt;

&lt;p&gt;Example 1:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class MockJsonRpcService {
  public function json_call($server, $jsonCall) {
   return array($item1, $item2);
 }
}
$remoteReader = new remoteItemsReader(new MockJsonRpcService());
assert($remoteReader-&amp;gt;read_items_from_external_shop() == array($item1, $item2));
// pseudo code here... see phpunit manual..
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;example 2:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class MockOrderReader {
 public function read($orderNumber) {
  return array($itemA, $itemB, $itemC);
 }
}
$orderDisplayer = new OrderDisplayer(new MockOrderReader());
assert($orderDisplayer-&amp;gt;toXml(1), &amp;quot;ABC&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And so on&amp;hellip; having followed the constructor-setter approach we can now test each bit separately. Then, everytime you need a real OrderDisplayer you have to type all this stuff:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$orderDisplayer = new OrderDisplayer(new OrderReader(new ItemsReader(new ItemsMapper(new db_Adapter), new RemoteItemsReader(new JsonRpcService(new HttpService))), new DeliveryCalculator()))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By doing this we &amp;ldquo;inverted the control&amp;rdquo;&amp;hellip; instead of creating object inside the classes that uses them, we create them all inside the current file&amp;hellip; but the length of this line is far from ideal. Here what comes really handy is having a Dependency Injection Framework. Internally in our company we use our own framework which is really helpful in this case: just write the xml to do the autowiring.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
http.service
jsonrpc.service&lt;/p&gt;

&lt;p&gt;db.adapter
items.mapperremote.items.reader&lt;/p&gt;

&lt;p&gt;items.readerorder.delivery.calculator
order.reader
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Done this, to use the real orderDisplayer:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$orderDisplayer = $serviceLocator-&amp;gt;getService(&amp;ldquo;order.displayer&amp;rdquo;);
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This is the end of the explanation. Doing in this way in my opinion makes it all less complicated (when you got your head around it), and you can still build really high level abstractions, with lots of objects calling other objects, and it&amp;rsquo;s still clear what is happening.&lt;/p&gt;

&lt;p&gt;There are some open source dependency injection frameworks available, Symfony has one for instance.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;d like to hear from you what you think&amp;hellip; would you solve it in another way?&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>